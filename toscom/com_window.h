/*
 *****************************************************************************
 *
 * 共通部ウィンドウ機能    by TOS
 *
 *   ウィンドウ機能が必要な場合のみ、このヘッダファイルをインクルードし、
 *   com_window.hをコンパイルするソースに含めること。
 *
 *   このファイルより先に com_if.h をインクルードすること。
 *
 *   現在のウィンドウ機能
 *   ・COMWINBASE: ウィンドウ機能基本I/F
 *   ・COMWINCONT: ウィンドウ制御I/F
 *   ・COMWINDISP: ウィンドウ出力I/F
 *   ・COMWINKEY:  ウィンドウ入力I/F
 *   ・COMWINDBG:  ウィンドウ機能デバッグ関連I/F
 *
 *   cursesの昨日を全面的に利用するため、
 *     ncurses
 *     ncurses-devel
 *     ncurses-lib
 *   がインストールされている必要がある(そうしなければヘッダファイルも無い)。
 *   例えば「rpm -qa | grep ncurses」でインストール状況は確認出来るだろう。
 *
 *   加えてコンパイル時に「-lpanel -lncursesw」のライブラリ指定も必要になる。
 *
 *   本ヘッダは試験運用レベルのものとなる。まだ色々試行の余地があり、
 *   その結果分かったことは可能な限り本ヘッダファイルに記述した。
 *
 *****************************************************************************
 */

#pragma once

#ifndef USE_FUNCTRACE
#define _XOPEN_SOURCE_EXTENDED
#endif

#include <panel.h>
#include <ncurses.h>
#include <locale.h>
#include <wchar.h>
#include <wctype.h>

/*
 *****************************************************************************
 * COMWINBASE:ウィンドウ機能基本I/F
 *****************************************************************************
 */

// ウィンドウ機能エラーコード宣言  ＊連動テーブルは gErrorNameWindow[]
enum {
    COM_ERR_WINDOWNG     = 950,    // ウィンドウ関連NG
};

/*
 * ウィンドウ機能初期化  com_initializeWindow()
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * com_initialize()の後に、これも実行すること。
 * COM_INITIALIZE()マクロを使用する場合、直接 本I/Fの記述は必要なく、マクロを
 * 記述しているソース冒頭で、本ヘッダファイルをインクルードするだけで良い。
 */
void com_initializeWindow( void );



// ---------------------------------------------------------------------------
// ウィンドウ機能概要
// ---------------------------------------------------------------------------
// cursesを利用して、表示位置を指定した文字出力や、
// エンターキーを必要としない文字入力を可能とする特別なモードを実現する。
// toscomではこのモードを「ウィンドウモード」と称する。
// 現状は「ウィンドウ」だけに対応しており「パッド」には対応していない。
//
// com_readyWindow() を一番最初に必ず呼ぶ。
// これが init_scr()などウィンドウ機能に必要な設定を行うものとなっている。
//
// これにより ID=0の基本となるウィンドウが生成される。
// cursesライブラリでは「stdscr」とか「スクリーン」と呼ばれるもので、
// サイズは呼んだ時点の端末ウィンドウ全体を使ったものとなっている。
// このウィンドウは階層的に一番下に固定され、階層を動かすことは出来ないし、
// 削除もできない。ウィンドウモードを終了することで、このウィンドウは消える。
//
// 現時点でこの最初のウィンドウのサイズを変更することには対応していない。
//
// 以後、com_createWindow()で この上にウィンドウを追加できる。
// これは「cursesの stdscr上に生成するウィンドウ」ということになる。
// ウィンドウの重なりや移動の表示に Panelライブラリの機能を使用している。
// ウィンドウは IDで管理され、追加時に通知される。以後の操作に必ず必要となる。
//
// 追加したウィンドウを画面に出すには com_refreshWindow() を使用する。
// この再描画I/Fはウィンドウになにか変化があるたびに使用する。
//
// ウィンドウのうち、どれかひとつが「アクティブウィンドウ」になる。
// 文字入力や操作対象を示すカーソルはアクティブウィンドウにのみ現れる。
//
// 最初は ID=0のウィンドウ(=stdscr)がアクティブになる。
// com_activateWindow()で任意のウィンドウをアクティブに出来る。
// ウィンドウIDが必要なI/Fにおいて、ID値の代わりに COM_ACTWIN を指定すると
// その時のアクティブウィンドウに対する操作ができるようになっている。
//
// com_moveWindow()・com_floatWindow()・com_sinkWindow()で移動ができる。
// com_hideWindow()で表示/非表示を切り替えられる。
//
// com_printWindow() か com_printw()でウィンドウに対して文字出力する。
// この２つの処理差分は以下になる。
// ・com_printWindow()
//    カーソル位置に文字列を出力後、カーソル位置は移動しない。
//    文字出力後 自動で com_refreshWindow()を呼ぶ。
//    画面右端を超えた時の処理が独自のものになる。
// ・com_printw()
//    カーソル位置に文字列を出力後、カーソル位置を出力した文字の直後に移動。
//    com_refreshWindow()は実施しないので、呼び元で別途必要。
//    画面右端を超えた時は、無常家で折り返し出力となる。
// 
// com_mprintWindow() と com_mprintw() は表示位置も指定できる。
// 文字出力後のカーソル位置は、com_mprintWindow()は変動せず、com_mprintw()は
// 出力した文字の直後に移動する。カーソル位置と表示位置の違いに注意すること。
//
// com_setWindowKeymap()で、ウィンドウごとに「キーマップ」を指定可能。
// これは特定のキーを押した時に関数コールバックを実施する仕掛け。
// この設定後 com_checkWindowKey()でキー入力を待つことが出来る。
//
// com_inputWindow()で、ウィンドウに対して文字列入力も可能。
// これは Enterを押して文字入力完了となるタイプのもの。
//
// com_deleteWindow()で使い終わったウィンドウを削除し、リソースを解放する。
//
// com_finishWindow()でウィンドウモード自体を終了する。
// この時残っていたウィンドウは全て自動で com_deleteWindow()で削除する。
// プログラム終了時もこのI/Fは呼ばれる。



// ---------------------------------------------------------------------------
// WINDOW*型について
// ---------------------------------------------------------------------------
// cursesがウィンドウを管理するための型が WINDOW型となっている。
// toscomでウィンドウ操作をする場合、この型は隠蔽されていて、ウィンドウIDで
// 簡単に処理できるように見せている。が機能的に限定があるのは間違いない。
//
// toscomのI/Fを使わずに、cursesのライブラリを直接使用する余地も残すため、
// com_getWindowInf()でウィンドウIDに対応する WINDOW*型ポインタも取得可能。
//
// WINDOW*型を使ってライブラリを使用する例として「スクロール」を挙げる。
// 何も指定しない場合(＝toscomでそのままウィンドウを使用する場合)、
// ウィンドウ内の文字列はスクロールしない。
//
// これに関しては以下のライブラリ関数で設定が出来る。
//     scrollok()    ウィンドウのスクロール可否を設定
//     idlok()       ウィンドウのハードウェアスクロール使用を設定
//     wsetscrreg()  ウィンドウのスクロール範囲を設定
// こうした関数を使用したい場合、WINDOW*型が必要になる。toscomでこれらを
// 設定するI/Fは敢えて用意していないので、必要があれば使用を検討する。
//
// 単純に scrollok()で trueに指定すると cursesのソフトウェアスクロールになる。
// 例えば teratermを使っていて、スクロールバーで戻した時にバックログが欲しい
// と思ったら、これでは駄目でハードウェアスクロールが必要になる。その時は
// idlok()で trueを指定する、という寸法になる。
//
// man curs_outopts と打つと、関連するライブラリ関数の情報を確認可能。
// サンプルの「コミュニケーター」はスクロール設定もしているので参考に。



// ---------------------------------------------------------------------------
// curses使用時に参考にできる情報ソース (toscomでも参考にした)
// ---------------------------------------------------------------------------
//   http://www.on-sky.net/~hs/misc/?NCURSES+Programming+HOWTO#l0
//   http://www.fireproject.jp/feature/c-language/curses/basic.html
//   http://www.kis-lab.com/serikashiki/man/ncurses.html
//   http://www.kushiro-ct.ac.jp/yanagawa/ex-2017/2-game/01.html
//
//   *** 上記は 2021年10月時点の存在を確認済み ***



/*
 *****************************************************************************
 * COMWINCONT:ウィンドウ制御I/F
 *****************************************************************************
 */

// ウィンドウID型
typedef long  com_winId_t;

// ウィンドウID用 定数
#define  COM_ACTWIN   LONG_MIN    // アクティブウィンドウ指定値
#define  COM_NO_WIN   -1          // ウィンドウID 処理NG

//テキストID型
typedef long  com_winTextId_t;

// ウィンドウ情報構造体
typedef struct {
    com_winId_t      id;           // ウィンドウID
    BOOL             border;       // ウィンドウ枠線有無
    BOOL             hide;         // 非表示設定
    WINDOW*          window;       // ウィンドウ情報
    PANEL*           panel;        // パネル情報
    com_hashId_t     keyHash;      // キーマップ用ハッシュテーブルID
    com_hashId_t     mixKeyHash;   // 他ウィンドウのキーマップを使う場合のID
    com_winTextId_t  textId;       // com_inputText()の入力データID
    com_hashId_t     intrHash;     // com_inputText()割込用ハッシュテーブルID
} com_cwin_t;

// カーソル位置構造体
typedef struct {
    int  x;
    int  y;
} com_winpos_t;
// cursesのライブラリ関数は y,x の順で引数とするのが基本となっているが
// 直感的に分かりづらかったため、toscomでは x,y の順で宣言した。


/*
 * ウィンドウモード開始  com_readyWindow()
 *   処理成否を true/false で返す。
 *   既に com_readyWindow()実施済みの場合、何もせずに falseを返す。
 *   ウィンドウモードの終了には必ず com_finishWindow()を使用して、
 *   ウィンドウ用のリソース解放を実施すること。
 * ---------------------------------------------------------------------------
 *   COM_ERR_WINDOWNG: initscr()失敗。色指定不可能な端末色指定。
 *   ウィンドウ追加のための com_realloc()や com_registerHash()によるエラー。
 *   なお com_registerHash()はエラー発生時プログラムを強制終了する仕様。
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * ウィンドウモードを開始する。
 *
 * iOptにはオプション設定を格納した構造体のアドレスを指定する。
 *  .noEnterを trueにすると、文字入力に Enter押下不要となる。
 *  .noEchoを trueにすると、文字入力後にその文字を画面に出力しない。
 *  .keypadを trueにすると、キーパッドが有効になる。
 *    cursesを使用する場合、上記3つは全て trueにするのが基本とされている。
 *    ただ .keypadを trueにすると teratermの画面上でマウススクロールが効かない
 *    現象が発生した。画面のバックスクロールも使いたいと思う場合 falseが良い。
 *    ただその場合キー入力で KEY_ で始まるマクロは使用できない。
 *  .colorsは指定したい色設定。色設定が不要なら NULLを指定する。
 *    最終データの .pairを 0にした線形(配列)データを指定する。
 *    ここで色設定しておくと、以後 ライブラリのマクロ COLOR_PAIR(n) で
 *    色指定が可能となるように init_pair()によるデータ登録が行われる。
 *    com_readyWindow()実行後、自力で init_pair()による登録をしても問題ない。
 *    COLOR_PAIR(n)による色指定が可能なのは、com_setBackgroundWindow()の iCh、
 *    com_mprintw()や com_mprintWindow()の iAttrが挙げられる。
 *
 * oSizeを指定すると、strscrのサイズ(その時点の端末ウィンドウサイズ)を格納する。
 * 格納が不要なら NULL指定する。
 *
 * 本I/Fにより strscrがウィンドウID=0で開始する。これは固定ウィンドウとなる。
 * 以後 com_createWindow()により、stdscr上にウィンドウが生成され、1以上の
 * ウィンドウIDが通知される。ウィンドウIDはウィンドウ操作に必要なものだが、
 * I/Fによっては 0を指定するとエラーになるものも存在する。
 *
 * ロケールも設定するため、ワイド文字が使用可能になる。
 * com_inputWindow()ではワイド文字も使って、日本語文字入力が矛盾なく出来る
 * ことを目指している。
 *
 * 本I/Fを使用すると、一時的に com_printf()や com_debug()などの標準出力は
 * 完全に抑制され、ウィンドウ機能で提供する以下のI/F以外で文字出力出来ない。
 *   com_printw()/com_mprintw()/com_printWindow()/com_mprintWindow()
 * その場合でもデバッグログへの出力はされているので、ログ出力目的で、
 * com_printf()等を使用することは出来る。
 * この画面抑制はデバッグログ上で「>> window mode start <<」と出力されてから
 * com_finishWindow()実施で「>> window mode end <<」と出るまで継続される。
 */

// 色指定データ型
typedef struct {
    short pair;   // COLOR_PAIR(n)の nで指定するペア番号
    short fore;   // 文字色
    short back;   // 背景色
} com_colorPair_t;

// 各種フラグ型
typedef struct {
    BOOL noEnter;   // 文字入力をエンター押下不要にするかどうか
    BOOL noEcho;    // 入力文字を画面出力するかどうか
    BOOL keypad;    // キーパッドを有効にするかどうか
    com_colorPair_t *colors;
} com_winopt_t;

BOOL com_readyWindow( com_winopt_t *iOpt, com_winpos_t *oSize );

// com_colorPair_tの .fore や .back に指定できる色のマクロとして、
// cursesでは以下が用意されている(その右に実際の数値も示す)。
//     COLOR_BLACK      0
//     COLOR_RED        1
//     COLOR_GREEN      2
//     COLOR_YELLOW     3
//     COLOR_BLUE       4
//     COLOR_MAGENTA    5
//     COLOR_CYAN       6
//     COLOR_WHITE      7
// cursesライブラリ関数 init_color()で独自色を作成することも可能。
// RGBを0-1000の範囲で指定するもので .fore や .back に直接指定で良いだろう。
// この関数の第1引数 color は 8以上を指定して、上記の設定と被るのを避け、
// 以後 COLOR_PAIR(n)の nとして使うと良いだろう。


/*
 * ウィンドウ生成  com_createWindow()
 *   生成したウィンドウのウィンドウIDを返す。生成失敗時は COM_NO_WIN を返す。
 *   使用を終えたウィンドウは com_deleteWindow()で個別にリリース解除すること。
 *   com_finishWindow()で残存ウィンドウを一気に削除も可能。
 * ---------------------------------------------------------------------------
 *   COM_ERR_WINDOWNG: newwin()に失敗。
 *   ただしNG発生時はプログラムを強制終了する。
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * 新たなウィンドウを stdscr上に生成する。
 * iPosはウィンドウの開始位置、iSizeはウィンドウサイズを設定する。
 * iBorderを trueに設定すると、枠線ありのウィンドウになる。ウィンドウ内で
 * カーソルが移動できる範囲は枠線のさらに内側に固定される。枠線は上書きしない
 * ようにウィンドウサイズを判定する。
 *
 * com_activateWindow() や com_refreshWindow() により、生成したウィンドウを
 * 表示させる。
 *
 * 複数のウィンドウの重なりについては Panelライブラリを利用して実現するが、
 * それを使う側が意識する必要はない。ウィンドウの表示階層を変更したい時は
 * com_floatWindow()や com_sinkWindow()を使用する。
 */
com_winId_t com_createWindow(
        const com_winpos_t *iPos, const com_winpos_t *iSize, BOOL iBorder );


/*
 * ウィンドウ存在チェック  com_existWindow()
 *   指定ウィンドウが存在する場合(隠蔽されている場合も含む)、true を返す。
 *   削除されているか、生成されていない場合は false を返す。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウが存在するなら trueを返す。
 * com_hideWindow()で隠蔽されている場合でも、存在するなら trueを返す。
 *
 * その iIdで生成されたウィンドウが存在しないときや、生成はされていたが
 * com_deleteWindow()で削除されていた時は falseを返す。
 *
 * ウィンドウ関連のI/Fでは存在しない iIdが指定された時に COM_ERR_DEBUGNG の
 * エラーを出すものが多い。そうしたエラーを防ぐ目的で、本I/Fにより、
 * iIdが有効なものかチェックをすることが出来る。
 */
BOOL com_existWindow( com_winId_t iId );


/*
 * バッググラウンド指定  com_setBackgroundWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウのバックグラウンド(背景)を設定する。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * iChに文字を指定すると、それがそのウィンドウの背景となり、com_clearWindow()
 * を使った時に、その文字でウィンドウを埋める。デフォルトは ' ' (半角空白）が
 * 指定されている状態と考えて良い。
 * iChに COLOR_PAIR(n)を指定すると、それが背景色になる。色の指定をしたい場合、
 * com_readyWindow()で使いたい色の設定を登録する必要がある。
 */
BOOL com_setBackgroundWindow( com_winId_t iId, chtype iCh );


/*
 * ウィンドウアクティベート  com_activateWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 *   指定ウィンドウが com_hideWindow()で隠蔽されている場合も falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウをアクティブにし、表示階層を一番上にする。
 * カーソルもそのウィンドウ内に移動する。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。(・・が、
 * 本I/Fでそれはあまり意味が無いようには思われる)
 *
 * com_hideWindow()で隠蔽されている場合、何もせずに falseを返す。
 * この場合エラー出力は一切ない。
 *
 * com_refreshWindow()相当の処理を内部で実施している。
 */
BOOL com_activateWindow( com_winId_t iId );


/*
 * ウィンドウ更新  com_refreshWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時は falseを返す。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * 現在の状態でウィンドウ表示を更新する。
 * この際、カーソルをアクティブウィンドウに戻す。
 *
 * 本I/Fを呼ぶか同等処理を実施するI/Fも多い。それについてはI/F説明で明記する。
 * 実施していないI/Fは、そのI/F使用後、明示的に本I/Fか同等処理を実施するI/Fを
 * 使用しないと、その結果が反映されない。こうしたI/Fとしては
 *   com_fillWindow()
 *   com_clearWindow()
 *   com_printw()/com_mprintw()
 * が挙げられる。これらはウィンドウ内表示を色々組み替えた後、最終結果だけを
 * 綺麗に表示したい時に利用できる。
 *
 * Panelライブラリを使用している都合で、表示の更新は refresh()ではなく
 * update_panels()を使用している。
 * Panelライブラリをパネルを表示する場合、refresh()は使わない、とされている。
 * 従って、本I/Fを使わず手動で表示更新したい場合も refresh()や その派生の
 * wrefresh()は使わず、update_panels() -> doupdate() という手順にする必要が
 * ある。
 */
BOOL com_refreshWindow( void );


/*
 * ウィンドウ位置変更  com_moveWindow()
 *   処理成否を true/false で返す。
 *   com_readyWindow()未実施時・不正iId指定時・iId＝0指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId || !iId
 *                                || !iPos
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウを iPosで指定した位置に移動する。
 * strscr(iId=0のウィンドウ)の外に出るような移動はできない。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 * strscr(iId=0のウィンドウ)は移動できない。
 *
 * com_refreshWindow()相当の処理を内部で実施している。
 */
BOOL com_moveWindow( com_winId_t iId, const com_winpos_t *iPos );


/*
 * ウィンドウ階層アップ  com_floatWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時・iId＝0指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId || !iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウの表示階層を一番上にする。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 * strscr(iId=0のウィンドウ)は移動できない。
 *
 * 本来、Panelライブラリではひとつ上のパネルを取得することも出来る模様だが
 * 動作を検証したところ、NULLが入ったままで取得はできなかった。
 * このため、一番上への階層移動しか現状は対応していない。
 *
 * com_refreshWindow()相当の処理を内部で実施している。
 */
BOOL com_floatWindow( com_winId_t iId );


/*
 * ウィンドウ階層ダウン  com_sinkWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時・iId＝0指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId || !iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウの表示階層を一番下にする。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 * strscr(iId=0のウィンドウ)は移動できない。
 *
 * 本来、Panelライブラリではひとつ下のパネルを取得することも出来る模様だが
 * 動作を検証したところ、NULLが入ったままで取得はできなかった。
 * このため、一番下への階層移動しか現状は対応していない。
 *
 * com_refreshWindow()相当の処理を内部で実施している。
 */
BOOL com_sinkWindow( com_winId_t iId );


/*
 * ウィンドウ隠蔽設定  com_hideWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時・iId＝0指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId || !iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウについて、iHideが trueなら隠蔽、falseなら隠蔽解除。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 * (この指定は隠蔽時しか使えない)
 * strscr(iId=0のウィンドウ)は対象にできない。
 *
 * 隠蔽したウィンドウがアクティブウィンドウだった場合、生成順で次以降の
 * 隠蔽されていないウィンドウがアクティブに切り替わる。
 *
 * 隠蔽されたウィンドウは com_activateWindow()が無効になるため、
 * 再びアクティブにしたいと思ったら、まず隠蔽を解除しなければならない。
 *
 * com_refreshWindow()相当の処理を内部で実施している。
 */
BOOL com_hideWindow( com_winId_t iId, BOOL iHide );


/*
 * ウィンドウ情報取得  com_getWindowInf()
 *   該当するウィンドウIDを返す。
 *   該当ウィンドウが存在しない場合 COM_NO_WIN を返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId || !oInf
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウの管理データアドレスを *oInfに格納する。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * ウィンドウが存在していれば iIdをそのまま返す。COM_ACTWIN指定時は、
 * そのアクティブなウィンドウのウィンドウIDを返す。
 *
 * こうして得られるデータのメンバー window は cursesライブラリで使われている
 * WINDOW*型のデータであり、cursesライブラリを直接使いたい時に、その処理先を
 * 指定するのに多用される。
 */
int com_getWindowInf( com_winId_t iId, const com_cwin_t **oInf );


/*
 * 座標取得  com_getWindowPos()・com_getWindowMax()・com_getWindowCur()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 *                                || !oPos/!oSize/!oCur
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウの各種座標を取得する。
 *    com_getWindowPos() : 対象ウィンドウの左上位置を *oPosに格納。
 *    com_getWindowMax() : 対象ウィンドウのサイズを *oSizeに格納。
 *    com_getWindowCur() : 対象ウィンドウのカーソル位置を *oCurに格納。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * 実際は cursesライブラリ関数を使った結果が入るのみとなる。
 *    com_getWindowPos() : getbegyx()
 *    com_getWindowMax() : getmaxyx()
 *    com_getWindowCur() : getyx()
 * ちなみに上記のライブラリ関数もだが、座標指定が (y,x) となっている。
 * 直感的に混乱しそうだったので、toscomでは (x,y) の形式としている。
 */
BOOL com_getWindowPos( com_winId_t iId, com_winpos_t *oPos );
BOOL com_getWindowMax( com_winId_t iId, com_winpos_t *oMax );
BOOL com_getWindowCur( com_winId_t iId, com_winpos_t *oCur );


/*
 * ウィンドウ削除  com_deleteWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時・iId＝0指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId || !iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウを削除し、そのリソースを解放する。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * 削除したウィンドウがアクティブウィンドウだった場合、生成順で次以降の
 * 隠蔽されていないウィンドウがアクティブに切り替わる。
 *
 * strscr(iId=0のウィンドウ)の削除は com_finishWindow()で行う。
 * このI/Fはその時 その上に残っているウィンドウの削除も自動で実施する。
 *
 * com_refreshWindow()相当の処理を内部で実施している。
 */
BOOL com_deleteWindow( com_winId_t iId );


/*
 * ウィンドウモード終了  com_finishWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時は falseを返す。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * ウィンドウモードを終了し、ウィンドウに関する全リソースを解放する。
 *
 * 他に生成していたウィンドウがあったら、com_deleteWindow()で自動削除する。
 * キーマップを登録していた場合、その保持のためのハッシュテーブルも削除する。
 *
 * デバッグログ上は「>> window mode finish <<」と出力する。
 * 標準出力の抑制が、この時解除される。
 */
BOOL com_finishWindow( void );



/*
 *****************************************************************************
 * COMWINDISP:ウィンドウ出力I/F
 *****************************************************************************
 */

/*
 * ウィンドウフィル  com_fillWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウ内を iChで指定した文字で埋めた後、カーソル位置を
 * ウィンドウ左上端に移動させる。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * iChrは int型なので 文字列リテラル(""で囲んだ文字列)は指定できないことに
 * 注意すること。
 *
 * 別途 com_refreshWindow()が必要。
 */
BOOL com_fillWindow( com_winId_t iId, int iChr );


/*
 * ウィンドウクリア  com_clearWindow()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウに対し、wclear()で画面クリアを実施し、カーソル位置を
 * ウィンドウ左上端に移動させる。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * 別途 com_refreshWindow()が必要。
 */
BOOL com_clearWindow( com_winId_t iId );


/*
 * ウィンドウ内カーソル位置指定  com_moveCursor()
 *   処理成否を true/false で返す。
 *   ウィンドウ外の位置を指定した場合は、何もせずに falseを返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウ内のカーソル位置を iPosに移動させる。
 * Idに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * iPosに格納する座標はウィンドウ左上端を ( 0, 0 ) とした指定とする。
 * 座標に負数を使用した場合 ( -1, -1 ) をウィンドウ右下端とした指定と扱う。
 * ウィンドウ外の座標を指定した場合、ウィンドウ内に入る位置に補正し、falseを
 * 返す。
 */
BOOL com_moveCursor( com_winId_t iId, const com_winpos_t *iPos );


/*
 * ウィンドウ内カーソル位置移動  com_shiftCursor()・com_udlrCursor()
 *   処理成否を true/false で返す。
 *   ウィンドウ外の位置を指定した場合、*oBlockedを trueにして trueを返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 *   COM_ERR_DEBUGNG: [com_prmNG] com_udlrCursor()で 上下 or 左右の同時指定
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウ内のカーソル位置を移動させる。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * com_shiftCursor()は iShiftに入れた座標分加算する(負数で減算になる)。
 * com_udlrCursor()は iDirで指定した方向に iDistの距離分加算となる。
 * iDirは例えば右上に動かしたければ COM_CUR_UP | COM_CUR_RIGHT と言った指定を
 * すれば良いことになる。上下 または 左右 を同時指定は出来ない。
 *
 * ウィンドウ外に出るような移動があった場合、ウィンドウ端で移動は止まる代わり
 * *oBlockedに trueが格納される。com_moveCursor()と異なり、ウィンドウ外になる
 * 移動でも返り値は falseではなく trueになる。
 */
BOOL com_shiftCursor(
        com_winId_t iId, const com_winpos_t *iShift, BOOL *oBlocked );

BOOL com_udlrCursor( com_winId_t iId, int iDir, int iDist, BOOL *oBlocked );

enum {
    COM_CUR_UP    = 1,    // 上に移動
    COM_CUR_DOWN  = 2,    // 下に移動
    COM_CUR_LEFT  = 4,    // 左に移動
    COM_CUR_RIGHT = 8     // 右に移動
};


/*
 * ウィンドウ内文字列出力  com_printWindow()・com_mprintWindow()・
 *                         com_printw()・com_mprintw()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウに iFormat以降で指定した文字列を出力する。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * com_mprintWindow()/com_mprintw()では iPosで表示開始位置を指定可能。
 * NULL指定が可能で、その場合は 現在のカーソル位置が表示開始位置になる。
 *
 * com_printWinodw()/com_print()は 現在のカーソル位置が表示開始位置になる。
 * (さらに具体的には com_printWindow() は iPosが引数に含まれておらず、
 *  com_mprintWinodw() で、iPosを NULL 指定するマクロ関数となっている。
 *  com_printw()は com_mprintw() に対して、同様の指定をするマクロ関数である)
 *
 * iAttr は出力する文字列に対する装飾を指定する。0ならば何もしない。
 * 指定できる属性の例としては
 *   COLOR_PAIR(n)    nは com_readyWindow()で登録した色パターン値
 *   A_BOLD           強調
 *   A_REVERSE        反転
 *   A_UNDERLINE      下線
 * などが挙げられ | で並べて複数を併用することも可能。ただ COLOR_PAIR(n)と
 * A_～を | で並列すると「符号有無の差分」でコンパイル時に警告が出るので、
 * A_～ について (int)でキャストするなどの工夫が必要になる。
 *
 * iWrap はウィンドウ右端を超えた分をどう出力するかの指定となる。
 * trueの場合、次行に折り返す。最下行だった時は超えた分を切り捨てる。
 * falseの場合、ウィンドウ内に収まるように出力開始位置を左にずらす。1行に
 * 収まりきらない場合、超えた分は全て切り捨てる。
 * ウィンドウが枠線ありだった場合、その分 出力できる長さは縮まる。
 *
 * iWrapは com_mprintWindow() とマクロ派生の com_printWindow()にのみあり、
 * com_mprintw()/com_printw()はこの引数が存在せず、ウィンドウ右端になったら
 * 自動で折り返す(iWrapが trueのときと同じ動作)。
 *
 * どのような出力であれ com_mprintWindow()は元のカーソル位置は変更しない。
 * (マクロ派生である com_printWindow()ももちろん同様である)
 * 移動させたい場合は com_moveCursor()を使うか、com_mprintw()で出力する。
 * com_mprintw()/com_printw()は、文字出力後 カーソル位置をその文字列の直後に
 * 移動させる。
 *
 * com_refreshWindow()相当の処理を com_mprintWindow()/com_printWindow()は
 * 内部で実施するが、com_mprintw()/com_printw()は実施しない。
 * com_mrpintw()/com_printw()は複数の文字列出力で画面をきれいに整えた後、
 * com_refreshWindow()等で一気に結果を出す、といった使い方を想定する。
 */

/*
 * プロトタイプ形式 (この形で使用すること)
 *   BOOL com_printWindow(
 *           com_winId_t iId, int iAttr, BOOL iWrap, const char *iFormat, ... );
 */
#define com_printWindow( ID, ATTR, WRAP, ... ) \
    com_mprintWindow( (ID), NULL, (ATTR), (WRAP), __VA_ARGS__ )

BOOL com_mprintWindow(
        com_winId_t iId, const com_winpos_t *iPos, int iAttr, BOOL iWrap,
        const char *iFormat, ... );

/*
 * プロトタイプ形式 (この形で使用すること)
 *   BOOL com_printw( com_winId_t iId, int iAttr, const char *iFormat, ... );
 */
#define com_printw( ID, ATTR, ... ) \
    com_mprintw( (ID), NULL, (ATTR), __VA_ARGS__ )

BOOL com_mprintw(
        com_winId_t iId, const com_winpos_t *iPos, int iAttr,
        const char *iFormat, ... );



/*
 *****************************************************************************
 * COMWINKEY: ウィンドウ入力I/F
 *****************************************************************************
 */

/*
 * キーマップ登録  com_setWindowKeymap()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 *   データ登録時の com_addHash()によるエラー
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウにキーマップを登録する。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * iKeymapが実際に登録するキーマップ。
 * これは特定のキーが押された時にコールバックする関数の一覧となっていて、
 * .key を 0にしたデータを最終とする線形(配列)データの形で作成する。
 * もし .func を NULLにしていたら、そのキーを押しても何もしないことを示す。
 * キーマップ単体ではあまり意味がないが、com_mixWindowKeymap()を使って
 * 別キーマップを取り込んだ時、その中のキー操作を無効化するのに使える。
 *
 * 本I/Fでキーマップを登録後、com_checkWindowKey()を呼ぶと、
 * 登録されていたキーが押された時に、対応する関数をコールバックする。
 * この関数はキーが押されたウィンドウのウィンドウIDを通知する。
 *
 * 実際に何が押されたか知りたい時は com_getLastKey() を使用する。
 *
 * .keyに指定するのは文字なら 'a' といった指定で良い。
 * キー入力自体はgetch()で取得するので、そこから返る値が求められている。
 * man getch を見る限り、特殊キーを指定できるマクロが多数存在する。
 * これは com_readyWindow()で .keypad を trueにしていれば使用できる。
 * ただキーボードによっては上手く認識しないこともあり得るので、動作は要確認。
 * (man getchでも「全てに対応するわけではない」と明記されている)
 *
 * toscom動作検証で、押した時に getch()でマクロが返ったのを確認できたもの
 *   カーソルキー     KEY_UP/KEY_LEFT/KEY_RIGHT/KEY_DOWN
 *   Insert           KEY_IC
 *   Delete           KEY_BACKSPACE
 *   PageDown         KEY_NPAGE
 *   PageUp           KEY_PPAGE
 *   F5～F12          KEY_F(5)～KEY_F(12)
 * 以下のキーは KEY_～のマクロ宣言値ではなく、制御文字コードが getch()で返った。
 *   BackSpace        0x08 (BS)
 *   TAB              0x09 (HT)
 *   Enter            0x0A (LF)
 *   ESC              0x1B (EC)  反応までに一瞬遅延あり(getch()の仕様)
 * 
 * 上記に挙げたマクロや制御文字コード値は .key に指定できる。
 * マクロ宣言は /usr/include/curses.h に記述されている。
 *
 * なお以下のキーは押しても getch()では 0x7E しか返らなかった。
 *   F1～F4
 *   Home
 *   End
 *
 * ただ認識する/しないは使用するOSやPCによっても違いはあると思われる。
 */

// キーを押した時のコールバック関数プロトタイプ宣言
typedef void(*com_keyCB_t)( com_winId_t iId );

// キーマップ登録用構造体
typedef struct {
    long  key;
    com_keyCB_t  func;
} com_keymap_t;

BOOL com_setWindowKeymap( com_winId_t iId, const com_keymap_t *iKeymap );


/*
 * 他ウィンドウキーマップ併用設定  com_mixWindowKeymap()
 *   基本的に true を返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 *   データ登録時の com_addHash()によるエラー
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウに対し、iSourceIdで指定したウィンドウのキーマップも
 * 併用するように設定する。この設定をした場合、先に自ウィンドウのキーマップを
 * 検索し、見つからなかったら設定した別キーマップを検索するようになる。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * この設定で併用されるのは iSourceIdのウィンドウ自身のキーマップのみで、
 * そのウィンドウも com_mixWindowKeymap()を設定していたとしても、
 * その併用しているキーマップまでは参照しない。
 *
 * 併用キーマップでキーが認識された場合、コールバックされる関数では、
 * 引数で渡されたウィンドウIDで処理を切り分けるといった工夫が必要になるかも
 * しれない。
 *
 * iSourceIdに COM_ONLY_OWN_KEYMAP を指定すると、併用設定を解除する。
 * (ウィンドウ生成時はこれがデフォルトで設定されている)
 */
BOOL com_mixWindowKeymap( com_winId_t iId, com_winId_t iSourceId );

// 他ウィンドウのキーマップを使用しない指定(デフォルト)
#define COM_ONLY_OWN_KEYMAP  (LONG_MIN + 1)


/*
 * キーボードマッピングチェック  com_checkWindowKey()
 *   登録されたキーが押されたら、関数コールバック後 trueを返す。
 *   未登録キーが押されたり、ノンブロックモードでタイムアウト(キー押下なし)時は
 *   falseを返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウで getch()を使ったキー入力を受け付ける。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * iDelayは負数を指定するとブロックモードになり、キーが押されるまで止まる。
 * 0以上だとノンブロックモードになり、その数値をミリ秒とした時間 待機する。
 * それまでにキーが押されなかったら falseを返す。
 * キーが押されていない場合 com_getLastKey()は ERR を返す。
 * なお 0よりも 50ぐらいに設定したほうが、レスポンスは良い印象だった。
 *
 * com_setWindowKeymap()で登録したキーが押された時は、対応する関数をコール
 * バックし、その後 trueを返す。
 * 見つからない場合、com_mixWindowKeymap()の設定がある場合は、そちらで
 * 登録されたキーなら関数をコールバックして trueを返す。
 * (つまり、どちらにも登録がある場合、自ウィンドウ登録内容が優先される)
 * キーの登録がない場合は falseを返す。
 *
 * com_inputWindow()との同時使用は基本的に出来ない(条件次第)。
 * 同時使用に関する説明は com_inputWindow()の方に記載するので、そちらを参照。
 */
BOOL com_checkWindowKey( com_winId_t iId, int iDelay );


/*
 * 最終押下キー取得  com_getLastKey()
 *   com_checkWindowKey()で一番最後に押されたキーを返す。
 *   ノンブロックモード指定(iDelay >= 0)でキーが押されなかった時は ERR を返す。
 *   一度も com_checkWindowKey()が呼ばれていない状態の場合、0を返す。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * com_checkWindowKey()で押されたキーを知りたい時に使用する。
 * キーマップ未登録のキーで何が押されたかを知りたい時などが考えられる。
 * 
 * com_checkWindowKey()が呼ばれるたびに内容は変わるため、
 * 関数コールバック中や、com_checkWindowKey()呼出直後以外は値の正当性が
 * 保証できない。
 */
int com_getLastKey( void );


/*
 * 文字列入力  com_inputWindow()
 *   文字入力が完了したら trueを返す。
 *   文字入力中は falseを返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 *                                || !oInput || !iOpt || !oPos
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウで文字列入力を受け付ける。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * 文字列入力が完了したら、*oInputに取得した文字列のアドレスを格納して trueを
 * 返す。このアドレスのメモリ解放は不要だが、共通バッファなので再利用が必要な
 * 場合、返却後即座に別バッファに内容コピーすること。
 * (文字列入力完了のタイミングは iOpt->type によって変わる。
 *  COM_IN_TYPE_t の各タイプのコメントを参照)
 *
 * iOptは入力に関する諸条件を設定したデータのアドレスとなる。NULL指定不可。
 *
 *   .type が文字入力方式を決定する。(形式は COM_IN_TYPE_t のコメント参照)
 *
 *   .delay は負数だとブロックモードになり、キー入力があるまで止まる。
 *   0以上だとノンブロックモードになり、その数値をミリ秒とした時間 待機する。
 *   その時間が過ぎてもキーが押されない場合 false を返す。
 *   0よりも 50ぐらいに設定したほうが、レスポンスは良い印象だった。
 *
 *   .size に1以上を指定すると、そのバッファサイズに収まるまでの入力になる。
 *   (つまり文字列終端 '\0' も含めた入力内容となる)
 *   0を指定した場合、最大サイズ(COM_WINTEXT_BUF_SIZE)指定と扱われる。
 *   入力できる文字サイズについては、この後でもう少し説明する。
 *
 *   .echo に trueを指定すると、押した文字の内容を iIdのウィンドウ上に出力する。
 *   この出力にあたり、com_refreshWindow()相当の処理を実施する。
 *
 *   .clear に trueを指定すると、入力完了後 出力内容をクリアする。
 *
 * iPosは入力位置を指定する。NULL指定不可。
 * 文字入力が完了するまで同じ値を指定し続ける必要がある。
 * (文字入力が完了するまでに、本I/Fは複数回呼ばれる可能性がある)
 *
 *
 * .typeが COM_IN_1KEY で .echo が falseなら、com_setWindowKeymap()を使った
 * 文字入力と同じようなことがほぼ可能。(com_setWindowKeymap()の方が多分楽だが)
 *
 * .type が COM_IN_1LINE/COM_IN_MULTILINE の場合、BackSpaceを押すと 1文字戻る
 * 入力修正が可能。ただ後退して消えた部分の再表示が現状できない(今後の課題)。
 * また、ESCを押すと一瞬の間があるが、その後 入力をキャンセル可能。
 * (この一瞬の間は getch()の仕様なので、現状改善の余地はない)
 * あとは入力確定の Enter または Ctrl+D 以外の特殊キーは受け付けない。
 *
 *
 * 入力できる文字サイズ(1)
 *   文字列サイズ(iOpt->size)の最大値は COM_WINTEXT_BUF_SIZE で 4096 となる。
 *   このサイズは COM_WINTEXT_BUF_SIZE_SPEC を宣言するとその内容に変更できる。
 *
 *   また入力用の文字列バッファ数は COM_WINTEXT_BUF_COUNT で 5 となっており、
 *   同時に com_inputWindow()が使える数となっている。
 *   これは COM_WINTEXT_BUF_COUNT_SPEC を宣言するとその内容に変更できる。
 *
 *   com_spec.h で ～_SPECの宣言をするのが一番良い方法となる。
 *
 *
 * 入力できる文字のサイズ(2)
 *   対象ウィンドウが枠付き(com_createWindow()で iBorderが true)の場合、
 *   枠線を超える文字入力は出来なくしている。これは主に画面出力の問題で、
 *   そのまま入力を許容すると、枠線を無視した折返しになってしまうため。
 *
 *   枠なしウィンドウの場合、複数行にまたがる文字列入力を許容するが、
 *   ウィンドウのスクロールが出来ない場合、ウィンドウサイズを超えた入力が
 *   あった時、それが表示しきれなくなる。
 *
 *   com_getRestSize()によりウィンドウに収まる文字数は取得できるので、
 *   それを本I/Fの iOpt->size に設定するという方法が取れる。
 *
 *   スクロールに関しては本ファイルの冒頭「WINDOW*型について」にて、
 *   cursesライブラリ関数を使って設定する方法を紹介しているので、
 *   それも検討できるだろう。
 *
 *
 * com_checkWindowKey()との併用は注意
 *   com_inputWindow()と com_checkWindowKey()はどちらもキー入力を受け付ける。
 *   このため同時に使用すると押したキーがどちらのI/Fで拾われるか不定となり
 *   正しい入力が難しくなる。
 *
 *   com_inputWindow()をノンブロックで使い、falseが返る間はループさせる
 *   といった作りであれば、そのループ内で com_checkWindowKey()を使うことで
 *   同時に動作する事態は避けられるので、これは検討出来るかもしれない。
 */

// 入力タイプ
typedef enum {
    COM_IN_1KEY,       // キーを押した時点で、その文字を返す
    COM_IN_1LINE,      // エンターを押した時点で、その1行の文字列を返す
    COM_IN_MULTILINE   // Ctrl+Dを押した時点で、複数行の文字列を返す
} COM_IN_TYPE_t;

typedef struct {
    COM_IN_TYPE_t type;   // 入力タイプ
    int     delay;        // 受付待ち時間(負数でブロックモード)
    size_t  size;         // 入力最大サイズ(バッファサイズではない)
    BOOL    echo;         // 入力文字を画面出力するかどうか
    BOOL    clear;        // 入力完了時に画面出力クリアするかどうか
} com_wininopt_t;

BOOL com_inputWindow(
        com_winId_t iId, char **oInput, com_wininopt_t *iOpt,
        const com_winpos_t *iPos );

// 文字入力バッファは COM_WINTEXT_BUF_SIZE * COM_WINTEXT_BUF_COUNT と
// COM_WINTEXT_BUF_SIZE * 6 と、それなりに大きなメモリ領域を確保する。
// そのため、独自のマクロ宣言で大きさを調節できるようにする。
//
// COM_WINTEXT_BUF_SIZE_SPEC と COM_WINTEXT_BUF_COUNT_SPEC については、
// com_spec.h に記述することを想定する。宣言されていれば、その値を優先する。

#ifdef COM_WINTEXT_BUF_SIZE_SPEC
#define  COM_WINTEXT_BUF_SIZE  COM_WINTEXT_BUF_SIZE_SPEC
#else
#define  COM_WINTEXT_BUF_SIZE  COM_DATABUF_SIZE
#endif

#ifdef COM_WINTEXT_BUF_COUNT_SPEC
#define  COM_WINTEXT_BUF_COUNT  COM_WINTEXT_BUF_COUNT_SPEC
#else
#define  COM_WINTEXT_BUF_COUNT  5
#endif


/*
 * ウィンドウで打てる文字数算出  com_getRestSize()
 *   指定したウィンドウで入力可能な文字数を返す。
 *   com_readyWindow()未実施時・不正iId指定時は 0を返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウについて、現在のカーソル位置で com_inputWindow()を
 * 呼んだ後、入力できる最大文字数を計算して返す。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * 枠ありウィンドウの場合、右端の枠線直前までのサイズになる。
 * 枠なしウィンドウの場合、改行ありで 右下端までのサイズになる。
 *
 * あくまでウィンドウサイズに応じた計算であるため、スクロールありなら、
 * 本I/Fが返すより多くの文字列を入力可能となる。
 */
size_t com_getRestSize( com_winId_t iId );


/*
 * 割込キー登録  com_setIntrInputWindow()
 *   全ての登録が成功したら trueを返す。ひとつでも失敗したら falseを返す。
 *   com_readyWindow()未実施時・不正iId指定時は falseを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 *   データ登録時の com_addHash()によるエラー。
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウに対し、com_inputWindow()が呼ばれた時の割込キーを
 * 登録する(あくまで com_inputWindow()実行時のみ有効なキー登録となる)。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * iIntrKeyが実際に登録するキーの情報。
 * これは特定のキーが押された時にコールバックする関数の一覧となっていて、
 * .key を 0にしたデータを最終とする線形(配列)データの形で作成する。
 * 同じキーの登録があった場合、どんどん上書きし、最後のデータのみ有効となる。
 *
 * この割込設定は COM_IN_1LINE/COM_IN_MULTILINE が指定されている時に有効。
 * 対象となる com_inputWindow()を呼ぶ前に、本I/Fを使用する必要がある。
 *
 *
 * 登録できるキーの値は com_setWindowKeymap()と同じものになる。
 * Enter・BackSpace・ESC は処理が割り当てられているので、登録は避けるべき。
 * それ以外の特殊キーによる処理をしたい時に、本I/Fを使用する。
 * 例えば 上カーソルを押した時に、入力ヒストリに切り替える、といったことを
 * 実現するのに使えるだろう。(その機能は toscomでは未実装)
 *
 *
 * コールバックする関数は対象となるウィンドウのウィンドウIDを引数で通知する。
 * 返り値はそのまま com_inputWindow()に渡され、trueは入力完了、falseは入力継続
 * という意味合いで処理される。
 *
 * コールバック関数の中で入力中の文字列を参照/操作出来るようにするため、
 *    com_getInputWindow()
 *    com_setInputWindow()
 *    com_cancelInputWindow()
 * といったI/Fが用意されている。
 */

// キー割込コールバック関数プロトタイプ
typedef BOOL(*com_intrKeyCB_t)( com_winId_t iId );

// キー割込登録用構造体
typedef struct {
    long  key;
    com_intrKeyCB_t func;
} com_intrKey_t;

BOOL com_setIntrInputWindow( com_winId_t iId, const com_intrKey_t *iIntrKey );


/*
 * 入力中文字列取得  com_getInputWindow()
 *   指定したウィンドウで、com_inputWindow()により入力中の文字列内容の
 *   アドレスを返す。com_inputWindow()未実行時は NULLにを返す。
 *   com_readyWindow()未実施時・不正iId指定時も NULLを返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 *                                || com_inputWindow()未実行
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウで com_inputWindow()により入力中の文字列を返す。
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * com_inputWindow()ではワイド文字(wchar_t*型)で文字列を保持しているが、
 * それをマルチバイト文字(char*型)に変換した内容となる。
 *
 * 主に com_setIntrInputWindow()で登録されたコールバック関数内で、
 * 文字入力に何らかの干渉をするために使用する想定。
 */
char *com_getInputWindow( com_winId_t iId );


/*
 * 入力中文字列変更  com_setInputWindow()
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 *                                || com_inputWindow()未実行
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウで com_inputWindow()により入力中の文字列を、
 * iTextの内容で置き換える。
 * iIdに COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * com_inputWindow()ではワイド文字(wchar_t*型)で文字列を保持しているので、
 * iTextの内容も変換して置換する。ただし入力サイズのチェックはしないので、
 * コールバック関数側で com_getRestSize()を使うなどして、置換できるサイズを
 * 意識したコードを書く必要がある。
 *
 * 主に com_setIntrInputWindow()で登録されたコールバック関数内で、
 * 文字入力に何らかの干渉をするために使用する想定。
 */
void com_setInputWindow( com_winId_t iId, const char *iText );


/*
 * 文字列入力キャンセル  com_cancelInputWindow()
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] com_readyWindow()未実施 || 不正iId
 *                                || com_inputWindow()未実行
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 * iIdで指定したウィンドウで、com_inputWindow()の実行をキャンセルする。
 * (ESCを押したときと同じ動作になる）
 * COM_ACTWINを指定した場合、現在のアクティブウィンドウが対象となる。
 *
 * 主に com_setIntrInputWindow()で登録されたコールバック関数内で、
 * 文字入力に何らかの干渉をするために使用する想定。
 */
void com_cancelInputWindow( com_winId_t iId );



/*
 *****************************************************************************
 * COMWINDBG: ウィンドウ機能デバッグ関連I/F
 *****************************************************************************
 */

/*
 * ウィンドウモードデバッグ出力設定  com_setDebugWindow()
 * ---------------------------------------------------------------------------
 * ===========================================================================
 *   マルチスレッドで使用することは想定していない。
 * ===========================================================================
 */
void com_setDebugWindow( BOOL iMode );


// ウィンドウ機能 導入フラグ
#define USING_COM_WINDOW
// ウィンドウ機能 初期化関数マクロ  ＊COM_INITIALIZE()で使用
#ifdef  COM_INIT_WINDOW
#undef  COM_INIT_WINDOW
#endif
#define COM_INIT_WINDOW  com_initializeWindow()

