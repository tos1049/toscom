/*
 *****************************************************************************
 *
 * 共通部エキストラ機能     by TOS
 *
 *   エキストラ機能が必要な場合のみ、このヘッダファイルをインクルードし、
 *   com_extra.cをコンパイルするソースに含めること。
 *
 *   このファイルより先に com_if.h をインクルードすること。
 *
 *   現在のエキストラ機能
 *   ・COMEXBASE:  エキストラ機能基本I/F
 *   ・COMEXINPUT: キー入力関連I/F
 *   ・COMEXSTAT:  統計情報/数学計算I/F
 *   ・COMEXRAND:  乱数関連I/F
 *   ・COMEXSIG:   シグナル関連I/F
 *   ・COMEXPACK:  データパッケージ関連I/F
 *
 *   なお、本ヘッダファイルで float.h と math.h をインクルードするので、
 *   倍精度変数と各種数学関数も副次的に使用可能となる。
 *
 *****************************************************************************
 */

#pragma once

#include <float.h>
#include <math.h>
#include <signal.h>

/*
 *****************************************************************************
 * COMEXBASE: エキストラ機能基本I/F
 *****************************************************************************
 */

// エキストラ機能エラーコード定義  ＊連動テーブルは gErrorNameExtra[]
enum {
    COM_ERR_READTXTNG  = 930,        // 複数行テキスト読み込みNG
    COM_ERR_RANDOMIZE  = 931,        // 乱数生成NG
    COM_ERR_SIGNALING  = 932,        // シグナル関連NG
};

/*
 * エキストラ機能初期化  com_initializeExtra()
 * ---------------------------------------------------------------------------
 *   エラーは発生しない
 * ===========================================================================
 *   マルチスレッドで起動することは想定していない。
 * ===========================================================================
 * com_initialize()の後に、これも実行すること。
 * COM_INITIALIZE()マクロを使用する場合、直接 本I/Fの記述は必要なく、マクロを
 * 記述しているソース冒頭で、本ヘッダファイルをインクルードするだけで良い。
 */
void com_initializeExtra( void );



/*
 *****************************************************************************
 * COMEXINPUT: キー入力関連I/F
 *****************************************************************************
 */

/*
 * com_input()で使用する入力文字のチェック関数は com_if.h にて宣言された
 * コンフィグ値のチェック関数(com_validator_t)をそのまま使用可能。
 * このチェック関数の iCond には、各関数用の条件データを指定する。
 *
 * チェック結果は true (チェックOK)/false (チェックNG) で返す。
 * com_input()では、falseが返ったら再入力となる。
 * -------------------------------------------------------------------------
 * 一般的なパターンとして下記のチェック関数は com_if.h に存在する。
 *    com_valDigit()        long型数値範囲チェック
 *    com_valDgtList()      long型数値リストチェック
 *    com_valUDigit()       ulong型数値範囲チェック
 *    com_valUDgtList()     ulong型数値リストチェック
 *    com_valHex()          16進数範囲チェック
 *    com_valString()       文字列長範囲チェック
 *    com_valStrList()      文字列リストチェック
 *    com_valBool()         TRUE か FALSE (大文字/小文字区別なし)
 *    com_valYesNo()        YES か NO (大文字/小文字区別なし)
 *    com_valOnOff()        ON か OFF (大文字/小文字区別なし)
 *
 * com_extra.hで、更に以下のチェック関数を用意する。
 *    com_valOnlyEnter()    Enterキーのみ押下チェック
 *    com_valSaveFile()     保存ファイル名入力(既存なら上書き確認)
 *    com_valLoadFile()     読込ファイル名入力(存在するものを入力)
 *
 * Yes/No に関しては入力処理をよりサポートするために以下を用意する。
 * 以下の関数はチェック関数ではないので、com_input()の代わりに使用する。
 *    com_isYes()           文字列が YES か Y であることを判定
 *    com_askYesNo()        Yes/Noの入力を求め、true/falseで結果を返す。
 *
 * また com_select.h には以下のチェック関数が用意されている。
 *    com_valIpAddress()    IPアドレス(v4/v6指定可能)チェック
 *
 * 独自に com_validator_t型のチェック関数を自作しても、何も問題ない。
 * 例えば、上記のチェック関数を複数使った判定をしたいと思う場合、
 * 複数を呼んで判定する新たな関数を用意する必要がある。
 */

/*
 * エンターのみ入力チェック  com_valOnlyEnter()
 *   チェック結果を true/false で返す。
 *   com_input()で使用時は、falseが返ったら再入力となる。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで影響を受ける処理は無い。
 * ===========================================================================
 * 表示のウェイトのときなどに使用することを想定。
 * com_input()で iFlag->enterSkipを false にした場合、永久に抜けられなくなる
 * ので、その指定はしないように注意すること。
 *
 * 特に条件指定は無いため、com_input()での条件指定は NULL とする。
 *
 * リターン待ち処理を共通化した com_waitEnter() もあるので、特に問題が無ければ
 * そちらを使うことで、処理記述を簡略化出来るだろう。
 *
 * マクロ COM_VAL_ONLYENTER は
 * com_addCfgValidator()で本I/Fを使用するための宣言となる。
 * 詳細は com_addCfgValidator() の説明を参照。
 */

////////// com_addCfgValidator()で使用できる関数名マクロ //////////
#define COM_VAL_ONLYENTER \
    com_valOnlyEnter, NULL, NULL

BOOL com_valOnlyEnter( char *ioData, void *iCond );
// 条件はないので、コピー/解放関数も不要。

/*
 * 保存ファイル名チェック  com_valSaveFile()
 *   チェック結果を true/false で返す。
 *   com_input()で使用時は、falseが返ったら再入力となる。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで影響を受ける処理は無い。
 *   ただしファイル操作が別プロセスで行われることには対応できない。
 * ===========================================================================
 * ioDataをファイル名として扱い、ファイルが無ければ true を返す。
 * ファイルがあった場合は、上書き確認をし、Yesなら true、Noなら false を返す。
 *
 * iCondで条件を設定する。NULL指定時は条件は全て falseとして動作する。
 * iCondは com_valCondSave_t型のアドレスで、既存ファイルありのときの処理を
 * 制御する。
 * .fileExist は既存ファイルがあったときのメッセージ内容を指定する。
 *  ファイル名に当たる %s を必ず1回 文中に含めること。NULL指定時は
 *  "%s already exists. are you sure to overwrite?\n" となる。
 * .forceRerry を trueにすると、確認無しで、無条件 falseを返す。
 * .forceOverwrite を trueにすると、確認無しで 無条件 trueを返す。
 * もし .forceRetry と .forceOverwrite のどちらも true にした場合は、
 * .forceRetry が優先され、確認無しで falseを返す動作となる。
 * どちらかが true の場合 .fileEixst に設定した文字列は使用機会無しとなる。
 *
 * COM_VAL_SAVEFILE・com_valSaveFileCondCopy()・com_valSaveFileCondFree()は
 * com_addCfgValidator()で本I/Fを使用するための宣言となる。
 * 詳細は com_addCfgValidator() の説明を参照。
 */

////////// com_addCfgValidator()で使用できる関数名マクロ //////////
#define COM_VAL_SAVEFILE \
    com_valSaveFile, com_valSaveFileCondCopy, com_valSaveFileCondFree

// com_valSaveFile()用 条件指定構造体
typedef struct {
    char*  fileExist;        // ファイル存在時に出力する内容
    BOOL   forceRetry;       // true ならファイル存在時 確認無しで falseを返す
    BOOL   forceOverwrite;   // true ならファイル存在時 確認無しで trueを返す
} com_valCondSave_t;

BOOL com_valSaveFile( char *ioData, void *iCond );
// 以下は com_addCfgValidator() でのみ使用する
BOOL com_valSaveFileCondCopy( void **oCond, void *iCond );
void com_valSaveFileCondFree( void **oCond );

/*
 * 読込ファイル名チェック  com_valLoadFile()
 *   com_input()で使用時は、falseが返ったら再入力となる。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで影響を受ける処理は無い。
 *   ただしファイル操作が別プロセスで行われることには対応できない。
 * ===========================================================================
 * ioDataをファイル名として扱い、ファイルがあったら true を返す。
 * ファイルが無ければ false を返す。
 * "-" を入力した場合も、特別に true を返す。これは入力キャンセルを想定した
 * 動作となるが、使い方は呼び元に委ねられる。
 *
 * iCondで条件を設定する。NULL指定時は条件は全て falseとして動作する。
 * iCondは com_valCondLoad_t型のアドレスで、既存ファイルありのときの処理を
 * 制御する。
 * .cancel は"-"の代わりに許容する文字列を指定する(入力キャンセル用想定)。
 *  NULL指定時は上記説明通り "-" 入力時に trueを返すようになる。
 *  その後 呼び元で "-" だったら処理キャンセルとなるようにコードを書くこと。
 * .noFile はファイルが無かった時に出力する文字列を指定する。
 *  ファイル名に当たる %s を必ず1回 文中に含めること。NULL指定時は
 *  "%s not exist...\n" となる。
 * .noDisp が trueの場合、ファイルが無かったら何も出力せず falseを返す。
 *  この場合 .noFile の設定を使用する機会はなくなる。
 *  
 * COM_VAL_LOADFILE・com_valLoadFileCondCopy()・com_valLoadFileCondFree()は
 * com_addCfgValidator()で本I/Fを使用するための宣言となる。
 * 詳細は com_addCfgValidator() の説明を参照。
 */

////////// com_addCfgValidator()で使用できる関数名マクロ //////////
#define COM_VAL_LOADFILE \
    com_valLoadFile, com_valLoadFileCondCopy, com_valLoadFileCondFree

// com_valLoadFile用 条件指定構造体
typedef struct {
    char*  cancel;   // 入力キャンセルに使用する文字列(デフォルトは "-")
    char*  noFile;   // ファイルが無いときに出力する内容
    BOOL   noDisp;   // trueの場合 ファイルが無いときに 無条件で falseを返す。
} com_valCondLoad_t;

BOOL com_valLoadFile( char *ioData, void *iCond );
// 以下は com_addCfgValidator() でのみ使用する
BOOL com_valLoadFileCondCopy( void **oCond, void *iCond );
void com_valLoadFileCondFree( void **oCond );

/*
 * 文字列入力  com_input()
 *   有効な入力文字数を返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] !oData
 * ===========================================================================
 *   排他制御はしていないため、必要に応じて呼び元で実施すること。
 *   入力用バッファを分けたい時は com_inputVar()の使用を検討する。
 * ===========================================================================
 * oData で入力文字列バッファアドレス格納用のポインタを指定する。
 * (char*型で変数を定義し、&を付けて引数にすることを想定)
 * 内部定義の入力用共通バッファのアドレスを *oData に格納して返す。
 *
 * iVal は入力内容のチェック方法のデータアドレスを設定する。
 * チェック不要なら iVal 自体を NULL指定する。
 *  .func は使用するチェック関数を指定する。com_val～() を使用可能なほか、
 *   同じプロトタイプで自作した関数を指定しても問題ない。
 *  .cond はそのチェック関数で使用する条件データのアドレスを指定する。
 *   どんな型のデータかはチェック関数ごとに決まっているので、その型で
 *   データを作成し、そのアドレスを渡せば良い。条件不要なら NULL にする。
 *   void*型にしているので、キャスト無しでアドレスを直接渡せる。
 *
 * iFlag は入力プロンプトの挙動指定のデータアドレスを設定する。
 * フラグの内容については、構造体宣言を参照。
 * NULLを指定した場合、全て falseという扱いになる。
 *
 * iFormat以降は入力プロンプト文の文字列となる。書式文字列が指定可能。
 * 入力プロンプトが不要の場合 NULL を指定する。
 *
 * oDataで返されるデータバッファは解放不要だが、com_input()が呼ばれるたびに
 * クリアされて再利用されるため、入力後も内容保持が必要な場合は、com_input()
 * から返った後、速やかに別バッファにコピーすること。
 * もしくは com_inputVar()で格納先を直接指定する方が簡単かもしれない。
 */

// 入力チェック内容データ構造体
typedef struct {
    com_validator_t  func;    // 使用する入力チェック関数
    void*            cond;    // チェック条件
} com_valFunc_t;

// 入力時の動作フラグ設定構造体
typedef struct {
    BOOL   clear;       // true ならプロンプト表示前に画面クリア
    BOOL   enterSkip;   // true なら Enterのみで入力スキップ(0を返す)
} com_actFlag_t;

size_t com_input(
        char **oData, const com_valFunc_t *iVal,
        const com_actFlag_t *iFlag, const char *iFormat, ... );

/*
 * 文字列入力 (格納変数指定型)  com_inputVar()
 *   有効な入力文字数を返す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] !oData
 * ===========================================================================
 *   排他制御はしていないため、必要に応じて呼び元で実施すること。
 * ===========================================================================
 * 機能は com_input()とほぼ同じで、入力内容の格納先を自分で指定出来る点が
 * 異なる。格納先のアドレスを oDataで指定し、そのサイズを iSizeで指定する。
 * 文字列を入れるので「最大文字数 + 1」のサイズが必要になることに注意。
 * サイズを超えた文字列入力は切り捨てる。
 * 指定されたバッファの0クリアは行わないので、必要なら予備元で実施すること。
 */
size_t com_inputVar(
        char *oData, size_t iSize, const com_valFunc_t *iVal,
        const com_actFlag_t *iFlag, const char *iFormat, ... );

/*
 * 複数行テキスト入力  com_inputMultiLine()
 *   入力されたデータサイズを返す。
 *   0 なら、データ読み出しでNGが発生したことを示す。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] !oData
 *   COM_ERR_READTXTNG: テキスト読み込みの fread() でエラー発生
 * ===========================================================================
 *   排他制御はしていないため、必要に応じて呼び元で実施すること。
 * ===========================================================================
 * oDataは入力文字列格納用バッファ、iSizeはそのサイズを指定する。
 * その内容解釈は呼び元に委ねることとし、内容チェックは行わない。
 * 改行込みのテキストを受付、oDataに格納する。
 *
 * CTRL+D を押すと入力終了になる。
 * ただし最後が改行ではない場合、CTRD+D は2回入力する必要がある。
 *
 * iFormat以降は先に表示する入力プロンプトの内容となる。書式文字列が使用可能。
 * 入力プロンプト不要の場合、NULLを指定する。
 */
size_t com_inputMutliLine(
        char *oData, size_t iSize, const char *iFormat, ... );

/*
 * Yes/No入力支援  com_isYes()・com_askYesNo()
 *   "YES" か "Y" なら true、"NO" か "N" なら false を返す。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない
 * ===========================================================================
 *   排他制御はしていないため、必要に応じて呼び元で実施すること。
 * ===========================================================================
 * com_isYes()は iData が "YES" か "Y" なら true、それ以外なら false を返す。
 * 大文字/小文字は区別しない。主に com_input()で受け取った入力文字列を対象と
 * して想定しているが、他の文字列を対象にしても問題ない。
 *
 * com_askYesNo()は 内部で com_input()を使った文字入力を促し、
 * その入力結果が "YES" か "Y" なら true、"NO" か "N" なら false を返す。
 * 大文字/小文字は区別しない。
 * iFlag、iFormatとそれ以降は、そのまま com_input()に渡す。
 * iFormatを NULLにした場合、"(Yes/No)" という入力プロンプトになる。
 */
BOOL com_isYes( const char *iData );
BOOL com_askYesNo( const com_actFlag_t *iFlag, const char *iFormat, ... );

/*
 * 共通用エンター待機  com_waitEnter()
 * ---------------------------------------------------------------------------
 *   エラーは発生しない
 * ===========================================================================
 *   排他制御はしていないため、必要に応じて呼び元で実施すること。
 * ===========================================================================
 * iFormat以降は入力プロンプトの文字列となる。画面クリアはしない。
 * (クリアしたいなら、先に com_clear() を使うと良い)
 * iFormat を NULL指定した場合 "--- HIT ENTER KEY ---" をプロンプトとする。
 */
void com_waitEnter( const char *iFormat, ... );

/*
 * セレクター動作  com_execSelector()
 *   メニュー実行結果を返す
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] !iSelector
 *   メニュー内容保持のための com_realloct() によるエラー(プログラム強制終了)
 * ===========================================================================
 *   排他制御はしていないため、必要に応じて呼び元で実施すること。
 * ===========================================================================
 * iSelectorで定義されたメニューデータからメニューテキストを生成出力し、
 * 項目を数値入力待ちになる。数値入力すると、それに対応する関数を実行する。
 *
 * iSelector は com_selector_t型の線形データの先頭アドレスを想定する。
 * .code が 0になったデータを最後にすることで、そこまでの複数データを
 * メニューとして出力するようになる。
 *   .code はメニュー番号(0より大きな値で、2桁以内の数値を推奨)
 *   .label はメニュー項目の文字列(60文字未満を推奨)
 *   .check に関数が指定されている場合、その関数が trueを返したらメニュー表示、
 *    falseなら そのメニュー部分は空欄となる。チェック不要なら NULL指定する。
 *   .func は そのメニュー番号を入力された時に実行する関数で、その返り値を
 *    com_execSelector() は返す。NULL指定時は無条件で trueを返す。
 *
 *  ＊なお .check や .func は引数なしの関数であるため、
 *    何らかの引数が必要な処理にしたい場合 com_execSelector() は使えない。
 *    やり取りするデータをグローバル変数定義する方法は考えられるだろう。
 *
 * iPromptはメニューの書式を設定したデータのアドレスになる。
 *   .head はメニュー先頭に表示するヘッダ文字列(NULLなら何も表示しない)
 *   .foot はメニュー末尾に表示するフッタ文字列(NULLなら何も表示しない)
 *    メニュー本体は改行しないので、必要なら .foot に  "\n"を指定すると良い。
 *   .borderLf はメニュー番号による改行単位を指定する。
 *    例えば 10 にすると 1～9、10～19、20～29、…という単位で改行を入れる。
 *    メニュー番号に 0が指定できないので、最初の行は1つ数が減ることに注意。
 *   .prompt はメニュー各行の先頭に付する文字列を指定する。
 *    NULLなら何も付けずにメニュー表示を始める。
 *
 * メニュー表示後 com_input()を使って数値入力を行う。
 * iFlagは その com_input()にそのまま渡す動作フラグとなる。
 * メニューで表示した項目の数字だけを許容するようにチェック関数を設定する。
 *
 * 繰り返しになるが、数字を入力したら その番号の iSelector[]->func を
 * 関数コールし、その返り値をそのまま返す。
 */

// メニュー処理関数プロトタイプ
//   ユーザーにより入力されたメニュー番号を入力として渡す。
//   それ以外に渡すデータが必要な場合グローバル変数使用を検討する。
//   主に処理成否の意味で true/false を返すが、その使い方は呼び元次第。
typedef BOOL (*com_selectFunc_t)( long iCode );

// メニュー項目データ構造体
//   com_selector_t型の配列変数を定義する想定で、
//   その最後のデータは 必ず .code が 0以下となるようにする。
//   (その場合の .label・.check・.func の内容は不問。NULLが無難)
//   このデータがなければ com_execSelector()はメニュー項目データの終わりを
//   検出できない。
typedef struct {
    long               code;    // メニュー番号
    char*              label;   // メニュー項目名
    com_selectFunc_t   check;   // メニュー出現チェック関数(trueで出現)
    com_selectFunc_t   func;    // メニュー実行関数
} com_selector_t;

// プロンプト書式構造体
typedef struct {
    char*   head;       // メニューヘッダ
    char*   foot;       // メニューフッタ
    long    borderLf;   // メニュー番号による改行単位
    char*   prompt;     // 各行のプロンプト
} com_selPrompt_t;

BOOL com_execSelector(
        const com_selector_t *iSelector, const com_selPrompt_t *iPrompt,
        const com_actFlag_t *iFlag );


/*
 *****************************************************************************
 * COMEXSTAT: 統計情報/数学計算I/F
 *****************************************************************************
 */

// 統計データ計算用構造体
typedef struct {
    long   count;            // データ件数
    BOOL   needList;         // リスト保持要否
    BOOL   existNegative;    // 負数データ有無(負数が入力されると true)
    long*  list;             // データリスト (.needList が true時に生成)
    double total;            // 合計値     (統計計算に使用)
    double lgtotal;          // 対数合計値 (統計計算に使用)
    double rvtotal;          // 逆数合計値 (統計計算に使用)
    double sqtotal;          // 平方合計値 (統計計算に使用)
    double cbtotal;          // 立法合計値 (統計計算に使用)
    double fototal;          // ４乗合計値 (統計計算に使用)

    // 以下が統計計算の結果となる
    // .existNegative が true の場合、.hrmavr・.geoavr は計算せず 0固定

    long   max;              // 最大値 (maximum)
    long   min;              // 最小値 (minimum)
    double average;          // 算術平均値 (arithmetic average)
    double geoavr;           // 幾何平均値 (geometric average)
    double hrmavr;           // 調和平均値 (hermonic average)
    double variance;         // 分散 (variance)
    double stddev;           // 標準偏差 (standard deviation)
    double coevar;           // 変動係数 (coefficent of variation)
    double skewness;         // 歪度 (skewness)
    double kurtosis;         // 尖度 (kurtosis)
} com_calcStat_t;

/*
 * 統計データ計算開始  com_readyStat()
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] !oStat
 * ===========================================================================
 *   マルチスレッドの影響は受けない
 * ===========================================================================
 * 統計情報の計算データを初期化する。
 * com_calcStat_t型の変数を定義し、そのアドレスを oStatで渡す想定。
 *
 * iNeedListを true にすると、入力された数値データを oStat->list に保持する。
 * false の場合 入力データの保持が必要なら呼び元で実施すること。
 *
 * その後、com_inputStat() で ひとつずつ数値を入力し、その都度計算する。
 * 全ての処理が終わったら com_finishStat() で統計データのメモリ解放を実施する。
 *
 * 実際に算出されるデータが何かは com_calcStat_t型の説明を参照。
 */
void com_readyStat( com_calcStat_t *oStat, BOOL iNeedList );

/*
 * 統計データ入力  com_inputStat()
 *   処理成否を true/false で返す。
 *   falseになるのは、合計値や平方合計値でオーバーフローが発生した時、
 *   または 入力データを保持するメモリが確保できなかった時。
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] !oStat
 *   入力値を保持する場合(oStat->needList==true)のみ com_reallloct()のエラー
 * ===========================================================================
 *   マルチスレッドの影響は受けない
 * ===========================================================================
 * oStat は com_readyStat()で初期化済みのデータを指定する。
 * iData は実際の入力数値で、それを oStat内部で統計情報として計算し、
 * 結果を保持する。入力数値ひとつずつ 本I/Fを使用する必要がある。
 *
 * 統計情報の計算結果は oStatに格納されるだけで他に出力はしないので、
 * 画面出力は必要に応じて呼び元が構造体メンバーを指定して実施すること。
 * double型の数値出力時の書式文字列は %lf ではなく %f であることに注意。
 *
 * com_readyStat() で iNeedList を trueにしていた場合、
 * 入力された iDataをひとつずつメモリ確保して oData->list に保持する。
 * このメモリ確保は com_finishStat() を使用することで解放される。
 */
BOOL com_inputStat( com_calcStat_t *oStat, long iData );

/*
 * 統計データ計算終了  com_finishStat()
 * ---------------------------------------------------------------------------
 *   COM_ERR_DEBUGNG: [com_prmNG] !oStat
 * ===========================================================================
 *   マルチスレッドの影響は受けない
 * ===========================================================================
 * 統計データのメモリ解放を実施する。統計情報 oStat自体の解放は行わないので、
 * 動的に確保していた場合は、呼び元で責任を持って解放すること。
 */
void com_finishStat( com_calcStat_t *oStat );

/*
 * 素数判定  com_isPrime()
 *   素数であれば true、素数でなければ false を返す。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドの影響は受けない
 * ===========================================================================
 * iNumberが素数かどうかを、試し割り法で判定する。(つまり最も原始的手法)
 * 従って iNumber が大きくなればなるほど判定に時間がかかる。
 * ・・とはいうものの、例えば uint型の範囲の数値であれば、どんなに大きくても
 * ミリ秒オーダーであり、実用には足ることが多いと思われる。
 */
BOOL com_isPrime( ulong iNumber );



/*
 *****************************************************************************
 * COMEXRAND: 乱数関連I/F
 *****************************************************************************
 */



/*
 *****************************************************************************
 * COMEXSIG: シグナル関連I/F
 *****************************************************************************
 */



/*
 *****************************************************************************
 * COMEXPACK: データパッケージ関連I/F
 *****************************************************************************
 */

