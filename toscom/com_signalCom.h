/*
 *****************************************************************************
 *
 * 共通部シグナル機能 (解析/デコード共通処理)    by TOS
 *
 *   シグナル機能の、プロトコルの解析/デコードで使用する共通処理をまとめた。
 *   本ヘッダは com_signal.h でインクルードされているため、
 *   個別にインクルードするのではなく com_signal.h のみインクルードして、
 *   開発を進めること。
 *
 *   現在含まれている機能
 *   ・COMSIGCOM:     共通基本I/F
 *   ・COMSIGCOMANLZ: 解析I/F向け共通処理I/F
 *   ・COMSIGCOMDECO: デコードI/F向け共通処理I/F
 *   ・COMSIGCOMFRAG: 信号フラグメント処理I/F
 * 
 *****************************************************************************
 */

#pragma once

/*
 *****************************************************************************
 * COMSIGCOM: 共通定義I/F
 *****************************************************************************
 */

// PROTOCOL_AVAILABLE
//   AVAILABLEと書いておきながら、下記に示すプロトコルは、現状未対応。
//   今後 解析処理を書けたら・・という研究課題を示している。
enum {
    /*** ファイルタイプ (1-99) ***/
    COM_SIG_PPP           = 99,     // DLT_PPP (0x09) RFC1661
    /*** Link層 (101-199) ***/
    /*** Network層 (201-299) ***/
    /*** Transport層 (301-399) ***/
    /*** No.7(SIGTRAN) (401-499) ***/
    COM_SIG_ANSITCAP      = 499,
    COM_SIG_ANSIMAP       = 498,
    /*** Application層 (501-599) ***/
    COM_SIG_HTTP2         = 589,    //            RFC7540/7541
    COM_SIG_RADIUS        = 599,    // port 1645  RFC2865
    /*** プロトコル認識のみ (601-699) ***/
    /*** 内部処理用 ***/
    COM_SIG_ONLYHEAD =  -999     // ヘッダ編集のみ(com_setHeadInf()で使用)
};

/*
 * シグナル機能解析処理初期化  com_initializeAnalyzer()
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 * com_initializeSignal() から呼ばれるため、本I/Fを直接使用する必要はない。
 */
void com_initializeAnalyzer( void );


// 解析/デコード起点処理 /////////////////////////////////////////////////////

/*
 * 汎用信号解析  com_analyzeSignal()
 *   解析結果を true/false で返す。
 *   ioHeadは不要になったら com_freeSigInf()で解放する必要がある。
 * ---------------------------------------------------------------------------
 *   解析I/F検索のための com_searchSigAnalyzer()によるエラー
 *   実際に実行されたプロトコル解析I/Fによるエラー
 *   com_analyzeAsLinkLayer()・com_analyzeAsNetworkLayer() によるエラー
 * ===========================================================================
 *   マルチスレッドによる影響は無い。
 * ===========================================================================
 * ioHeadで与えられた信号データを解析する。
 * iDecode(解析結果を出力するかどうか)は解析I/Fにそのまま渡される。
 *
 * もし ioHead->sig.ptype にプロトコル種別が既に指定されていたら、
 * そのプロトコルの解析I/Fを呼び出す。直接呼ぶのと変わらない動作となる。
 * 特定のプロトコルとして解析させたいなら、ioHead->sig.ptype にその種別値を
 * 設定して、本I/Fを呼ぶことで対応した解析I/Fにかけられる。
 * (この方法はどちらかというと com_analyzeSignalToLast()で使われるだろう)
 * 
 * ioHead->sig.ptypeが COM_SIG_UNKNOWN だったら、
 * まず com_analyzeAsLinkLayer()による解析を試み、上手くいかなかったら
 * com_analyzeAsNetworkLayer()による解析を試みる。これも上手くいかなかったら
 * false を返して処理を終了する。
 */
BOOL com_analyzeSignal( com_sigInf_t *ioHead, BOOL iDecode );

/*
 * 汎用連続信号解析  com_analyzeSignalToLast()
 *   処理結果を true/false で返す。
 *   ioHeadは不要になったら com_freeSigInf()で解放する必要がある。
 * ---------------------------------------------------------------------------
 *   com_analyzeSignal()によるエラー
 * ===========================================================================
 *   マルチスレッドによる影響は無い。
 * ===========================================================================
 * ioHeadで与えられた信号データを com_analyzeSignal()を使って解析する。
 * iDecodeは com_analyzeSignal()にそのまま渡す。
 *
 * 解析の結果、次プロトコルスタックが存在する場合(ioHead->next.cnt > 0の時)は
 * その次プロトコルスタックを com_analyzeSignal()を使って解析する。
 * こうして信号の最後まで(もしくは解析が中断するまで)連続解析を実行する。
 *
 * com_analyzeSignal()で自動判別できるプロトコル(SLL/Ether2/ARP/IPv4/IPv6)
 * ではない場合、ioHead->sig.ptype にそのプロトコル種別を設定する必要がある。
 *
 * 解析した結果 ioHead に対しては、com_detectProtocol()を使うことで、
 * 特定プロトコルが含まれているかどうかや、最初のプロトコル種別が何かを
 * チェックすることが可能。
 */
BOOL com_analyzeSignalToLast( com_sigInf_t *ioHead, BOOL iDecode );

/*
 * 特定レイヤー信号解析  com_analyzeAsLinkLayer()・com_analyzeAsNetworkLayer()
 *   処理結果を true/false で返す
 *   ioHeadは不要になったら com_freeSigInf()で解放する必要がある。
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_analyzeAsLinkLayer( COM_ANALYZER_PRM );
BOOL com_analyzeAsNetworkLayer( COM_ANALYZER_PRM );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
long com_detectProtocol(
        com_sigInf_t ***oResult, com_sigInf_t *ioHead, long iProtocol );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_sigInf_t *com_getProtocol( com_sigInf_t *iHead, long iProtocol );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_decodeSignal( com_sigInf_t *iHead );



/*
 *****************************************************************************
 * COMSIGCOMANLZ: 解析I/F向け共通処理
 *****************************************************************************
 */

enum { COM_NO_MIN_LEN = 1 };

#define COM_SGTOP    (ioHead->sig.top)
#define COM_SGLEN    (ioHead->sig.len)
#define COM_SGTYPE   (ioHead->sig.ptype)
#define COM_ORDER    (ioHead->order)
#define COM_NEXTCNT  (ioHead->next.cnt)
#define COM_APRM     (&(ioHead->prm))

// 解析開始マクロ用処理 //////////////////////////////////////////////////////

// 解析I/Fの先頭は必ずこのマクロ
#define COM_ANALYZER_START( MIN_LEN ) \
    size_t  HDRSIZE = (MIN_LEN); \
    if( !com_checkAnalyzerPrm( COM_FILELOC, ioHead ) ) {return false;} \
    if( ioHead->isFragment ) {return true;} \
    if( com_isAllZeroBinary( COM_ANALYZER_VAR ) ) {return true;} \
    if( COM_SGLEN < HDRSIZE ) { \
        com_error( COM_ERR_ILLSIZE, "too short data length(%zu/%zu)", \
                   COM_SGLEN, HDRSIZE ); \
        return false; \
    } \
    BOOL  result = false; \
    com_sigInf_t  orgHead = *ioHead; \
    com_dummyAnlzPrm( COM_ANALYZER_VAR ); \
    do { \
        orgHead = *ioHead; \
        com_skipMemInfo( true ); \
    }while(0)

// 解析I/Fの最後は必ずこのマクロ
#define COM_ANALYZER_END \
    do { \
        if( result ) { \
            com_inheritRasData( ioHead ); \
            if( iDecode ) {com_decodeSignal( ioHead );} \
        } \
        else { \
            com_rollbackSignal( ioHead, &orgHead ); \
            if( iDecode ) { \
                com_dispSig( "ERORR", COM_SGTYPE, &ioHead->sig ); \
            } \
        } \
        com_skipMemInfo( false ); \
        return result; \
    }while(0)

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_checkAnalyzerPrm( COM_FILEPRM, com_sigInf_t *ioHead );
BOOL com_isAllZeroBinary( COM_ANALYZER_PRM );
void com_dummyAnlzPrm( COM_ANALYZER_PRM );
void com_inheritRasData( com_sigInf_t *ioHead );
void com_rollbackSignal( com_sigInf_t *oHead, com_sigInf_t *iOrgHead );


// プロトコル解析用共通処理 //////////////////////////////////////////////////

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_setHeadInf(
        com_sigInf_t *ioHead, com_off iLength, long iType, long iNextType );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
uint16_t com_getVal16( uint16_t iSource, BOOL iOrder );
uint32_t com_getVal32( uint32_t iSource, BOOL iOrder );

uint16_t com_setVal16( uint16_t iSource, BOOL iOrder );
uint32_t com_setVal32( uint32_t iSource, BOOL iOrder );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
uint32_t com_calcValue( const void *iTop, com_off iSize );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_advancePtr( com_bin **oTarget, com_off *oLength, com_off iAdd );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_sigInf_t *com_stackSigInf( com_sigInf_t *ioHead, com_sigInf_t *iSource );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_sigInf_t *com_getRecentStack( com_sigStk_t *iStk );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_stackMultiSignals(
        com_sigInf_t *ioHead, const char *iLabel, com_sigBin_t *iData );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_addPrm(
        com_sigPrm_t *oTarget, void *iTag, com_off iTagSize,
        void *iLen, com_off iLenSize, void *iValue );
BOOL com_addPrmDirect(
        com_sigPrm_t *oTarget, com_off iTag, com_off iLen, void *iValue );
BOOL com_addPrmTlv( com_sigPrm_t *oTarget, com_sigTlv_t *iPrm );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_sigTlv_t *com_getRecentPrm( com_sigPrm_t *iPrm );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_sigTlv_t *com_searchPrm( com_sigPrm_t *iTarget, com_off iTag );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_matchSigBin( const com_sigBin_t *iBin1, const com_sigBin_t *iBin2 );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_matchPrm( const com_sigTlv_t *iTlv1, const com_sigTlv_t *iTlv2 );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_dupPrm( com_sigTlv_t *oTarget, const com_sigTlv_t *iSource );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
ulong com_getBitField( ulong iSource, ulong iMask, long iShift );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */

// ノード情報データ構造
enum {
    COM_NODEADDR_SIZE = 16,
    COM_NODEPORT_SIZE = 8
};

typedef struct {
    long     ptype;                         // プロトコル種別
    com_bin  srcAddr[COM_NODEADDR_SIZE];    // 送信元IPアドレス
    com_bin  dstAddr[COM_NODEADDR_SIZE];    // 送信元ポート番号
    com_bin  srcPort[COM_NODEPORT_SIZE];    // 送信先IPアドレス
    com_bin  dstPort[COM_NODEPORT_SIZE];    // 送信先ポート番号
} com_nodeInf_t;

BOOL com_getNodeInf( com_sigInf_t *iHead, com_nodeInf_t *oInf );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_matchNodeInf( com_nodeInf_t *iInf1, com_nodeInf_t *iInf2 );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_reverseNodeInf( com_nodeInf_t *ioInf );


// テキストベースプロトコル解析用共通処理 ////////////////////////////////////

#define COM_CAP_CTYPE_MULTI     "multipart/mixed"
#define COM_CAP_CTYPE_APPETC    "application/"
#define COM_CAP_CTYPE_TXTETC    "text/"

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */

// 文字列とメソッド名の対応データ構造
typedef struct {
    const char*   token;
    long          sigType;
} com_sigMethod_t;

// com_sigMethod_t型テーブル最終データの .sigTypeに設定する値
enum { COM_SIG_METHOD_END = 99 };

BOOL com_getMethodName(
        com_sigMethod_t *iTable, void *iSig, const char **oLabel, long *oType );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_off com_getHeaderRest( char *iHdr, int iSep );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_off com_matchToken(
        char *iSource, const char *iTarget, BOOL iNoCase, const int iSpec );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_setTxtHeaderVal( com_sigTlv_t *oTlv, char *iHdr, int iSep );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
char *com_getTxtHeaderVal( com_sigPrm_t *iPrm, const char *iHeader );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */

// 内部で使用するデータ構造
typedef struct {
    com_sigInf_t*  head;
    com_off*       size;
} com_sigTextSeek_t;

char *com_getTxtHeader( com_sigInf_t *ioHead, com_off *oHdrSize );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_seekTxtHeaderPrm( char *iHdr, char *iPrm, char **oTop, com_off *oLen );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_getTxtBody(
        com_sigInf_t *ioHead, COM_PRTCLTYPE_t iNext, com_off iHdrSize,
        const char *iConLen, const char *iConType, const char *iMulti );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_analyzeTxtBase(
        com_sigInf_t *ioHead, long iType, COM_PRTCLTYPE_t iNext,
        const char *iConLen, const char *iConType, const char *iMulti );


// ASN.1形式解析用共通処理 ///////////////////////////////////////////////////

// パラメータ解析用定数
enum {
    COM_ASN1_UNIVERSAL  = 0x00,    // UNIVERSAL class
    COM_ASN1_APPLI      = 0x40,    // APPLICATION class
    COM_ASN1_CONTEXT    = 0x80,    // CONTEXT class
    COM_ASN1_PRIVATE    = 0xc0     // PRIVATE class
};

enum {
    COM_ASN1_PRMFORM    = 0x00,    // Primitive Form
    COM_ASN1_CONFORM    = 0x01     // Constructor Form
};

enum {
    COM_ASN1_EOC_TAG    = 0x00,
    COM_ASN1_EOC_LENGTH = 0x00
};

enum {
    COM_ASN1_BOOL       = 0x01,    // BOOLEAN type Tag
    COM_ASN1_INT        = 0x02,    // INTEGER type Tag
    COM_ASN1_BITSTR     = 0x03,    // BIT STRING type Tag
    COM_ASN1_OCTSTR     = 0x04,    // OCTET STRING type Tag
    COM_ASN1_NULL       = 0x05,    // NULL type Tag
    COM_ASN1_OBJID      = 0x06,    // OBJECT IDENTIFIER type Tag
    COM_ASN1_OBJDES     = 0x07,    // OBJECT DESCRIPTOR type Tag
    COM_ASN1_EXT        = 0x08,    // EXTERNAL type Tag
    COM_ASN1_REAL       = 0x09,    // REAL type Tag
    COM_ASN1_ENUM       = 0x0a,    // ENUMRATED type Tag
    COM_ASN1_SEQ        = 0x10,    // SEQUENCE(OF) type Tag
    COM_ASN1_SET        = 0x11     // SET(OF) type Tag
};

// Constructor Form判定マクロ
#define COM_ASN_ISCONST( TAG ) \
    COM_CHECKBIT( (TAG), COM_ASN1_CONFORM )

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_off com_getTagLength( com_bin *iSignal, com_off *oTag );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_getAsnTlv( com_bin **ioSignal, com_sigPrm_t *oPrm );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
BOOL com_searchAsnTlv(
        com_sigPrm_t *iPrm, uint32_t *iTags, size_t iTagsSize,
        com_sigBin_t *oValue );



/*
 *****************************************************************************
 * COMSIGCOMDECO: デコードI/F向け共通処理
 *****************************************************************************
 */

// デコードI/Fの先頭は必ずこのマクロ
#define COM_DECODER_START \
    do { \
        if( !iHead ) {return;} \
        if( iHead->isFragment ) {return;} \
        if( iHead->sig.ptype == COM_SIG_ALLZERO ) { \
            com_decodeData( iHead, "DATA" ); \
            return; \
        } \
    }while(0)

// デコードI/Fの最後は必ずこのマクロ
#define COM_DECODER_END \
    do { \
        for( long i = 0;  i < iHead->next.cnt;  i++ ) { \
            com_sigInf_t*  stk = &(iHead->next.stack[i]); \
            if( stk->sig.ptype == COM_SIG_CONTINUE ) { \
                com_decodeData( stk, "UNKNOWN " ); \
            } \
        } \
    }while(0)

// バイナリデータのダンプマクロ
#define COM_ASCII_DUMP( SIG ) \
    do { \
        com_printBin_t  flags = { .prefix = "#   ", .seqAscii = ": " }; \
        com_printBinary( (SIG)->top, (SIG)->len, &flags ); \
    }while(0)

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_decodeData( COM_DECODER_PRM, const char *iLabel );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_onlyDispSig( COM_DECODER_PRM );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_dispIfExist( com_sigPrm_t *iPrm, long iType, const char *iName );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_dispDec( const char *iFormat, ... );

void com_dispVal( const char *iName, long iValue );

enum { COM_NO_PTYPE = -1 };
void com_dispSig( const char *iName, long iCode, const com_sigBin_t *iSig );

ulong com_dispPrm( const char *iName, const void *iTop, com_off iSize );

// ペイロードデータ判定関数プロトタイプ
typedef BOOL(*com_judgeDispPrm_t)( com_bin iTag );

void com_dispPrmList(
        com_sigPrm_t *iPrm, long iTagSize, long iLenSize,
        com_judgeDispPrm_t iFunc );

void com_dispBin(
        const char *iName, const void *iTop, com_off iLength,
        const char *iSep, BOOL iHex );

void com_dispNext( long iProtocol, size_t iSize, long iType );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
long com_getSigType( com_sigInf_t *iInf );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */

// 文字列情報データ構造
typedef struct {
    long   code;
    char*  name;
} com_decodeName_t;

// リスト最終データマクロ
#define COM_DECODENAME_END    { -1, NULL }

char *com_searchDecodeName( com_decodeName_t *iList, long iType, BOOL iAddNum );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_decodeTxtBase(
        com_sigInf_t *iHead, long iType, const char **iHdrList,
        const char *iSigLabel, long iSigType, const char *iConType );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_dispAsnPrm(
        const com_sigPrm_t *iPrm, const char *iLabel, long iStart );



/*
 *****************************************************************************
 * COMSIGCOMFRAG: 信号フラグメント処理I/F
 *****************************************************************************
 */

// フラグメント処理結果
typedef enum {
    COM_FRG_ERROR = 0,    // フラグメント処理NG
    COM_FRG_OK    = 1,    // フラグメント不要
    COM_FRG_REASM = 2,    // フラグメントデータ結合完了
    COM_FRG_SEG   = 3,    // フラグメントデータ収集
} COM_SIG_FRG_t;

// 分割条件データ構造 (使い方は com_stockFragments()の説明を参照
typedef struct {
    long          type;    // 自プロトコル種別(COM_SIG_～)
    long          id;      // フラグメント識別子(プロトコル固有)
    com_sigBin_t  src;     // 送信元情報(必要があれば保持)
    com_sigBin_t  dst;     // 送信先情報(必要があれば保持)
    long          usr1;    // ユーザー情報1(プロトコル固有)
    long          usr2;    // ユーザー情報2(プロトコル固有)
} com_sigFrgCond_t;

// フラグメント管理情報データ構造
typedef struct {
    long               isUse;
    com_sigFrgCond_t   cond;
    com_sigFrg_t       data;
} com_sigFrgManage_t;

// 上記の .srcや .dstの内容を指定しやすくするマクロ
#define COM_BIN( ADDR ) \
    (com_bin*)( &(ADDR), sizeof(ADDR) )

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_freeSigFrgCond( com_sigFrgCond_t *oTarget );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_sigFrg_t *com_stockFragments(
        const com_sigFrgCond_t *iCond, long iSeg, com_sigBin_t *iFrag );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
com_sigFrgManage_t *com_searchFragment( const com_sigFrgCond_t *iCond );

/*
 *
 * ---------------------------------------------------------------------------
 *   エラーは発生しない。
 * ===========================================================================
 *   マルチスレッドで動作することは想定していない。
 * ===========================================================================
 *
 */
void com_freeFragments( const com_sigFrgCond_t *iCond );




// 機能導入フラグは USING_COM_SIGNAL1 に含まれるため、ここでは定義なし

